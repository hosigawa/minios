	设置页表取pte偏移地址时用了char类型操作，而计算用的偏移地址是数组下表，在char类型
的情况下相当于每次只向前移动一字节，而不是一个指针应该移动的4字节，从而导致pte的地址不
正确
	系统刚启动的时候没有页表可用，也没有可分配的物理空间。需要先建立一个4M的超级页，
在这个超级页中映射地址0和内核基地址。之所以映射地址0是因为切换页表后的瞬间系统还是运行
在低地址上的，在跳转到高地址前不这么做会导致发生缺页错误
	因为初始超级页表只映射了4M空间，因此第一次分配物理内存时只能使用4M，超出部分会报
缺页错误。利用这4M内存建立新页表，将剩余的可用内存也一并加入映射。这样系统就能使用一直
到PHYSICAL_END位置的物理内存了。这里涉及到KERN_BASE和PHYSICAL_END的取值问题。由于系统
采用线性的虚拟地址到物理地址的映射，因此操作系统无法使用KERN_BASE以上的物理地址，所以
KERN_BASE最好的取法是去最大物理内存的中间，32位页表最大映射4G内存，再此情况下KERN_BASE
取0x80000000能取得最大可用内存，增大会导致可供映射的虚拟地址减少，减小会导致用于映射的
物理地址不足。
	由于每个新进程都会拥有一份独立的内核页表，因此被映射的PHYSICAL_END越大，内核部分所
需要的映射页就越多。

2017-8-7
	进程通过中断进入内核后，如果被调度了，就不会返回，取而代之的是下个可运行进程
开始从它自己上次被调度的地方开始执行，执行过程是依次返回中断之前调用的函数，直到内核栈
上只剩下trap_frame帧，并从这个帧返回中断，离开内核回到用户空间。由于调度时swtch_uvm
函数设置了供中断调用的tss的esp为进程内核栈底，中断产生的trap_frame帧必然在内核栈最
底部。
	执行输出性质的系统调用的时候要关闭中断，不然系统调用执行到一半时钟中断过来调度进
程可能会导致输出函数产生混乱，此时时钟中断的中断帧会建立在系统调用之上，返回的时候
会返回两次中断。
	中断处理函数结束时不需要手动恢复中断位，因为中断之所以能产生，是因为eflags被设置为
允许中断，而中断返回时处理器会恢复eflags的值，因此正常返回中断必然能重新打开中断允许
标志。

